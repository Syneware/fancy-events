/*!
 * Fancy Events
 * https://github.com/Syneware/fancy-events
 *
 * Copyright (c) 2022 Syneware
 * Licensed under the MIT license. https://raw.githubusercontent.com/Syneware/fancy-events/master/LICENSE
 */
var EventEmitter=function(){"use strict";function e(e,t,s){return Object.defineProperty(e,t,{value:s,configurable:!0,writable:!0,enumerable:!0})}function t(e,t){return Object.prototype.hasOwnProperty.call(e,t)}return class{constructor({mode:s="wildcard",includeStack:i=!1,delimiter:r="."}={}){this._listeners={},this._wildcardsRegex={},this._listenerRegex={},this.mode="wildcard",this.includeStack=!1,this.delimiter=".",this.addListener=(e,t,s={})=>(Array.isArray(e)?e.forEach((e=>this._addListener(e,t,s))):this._addListener(e,t,s),this),this._addListener=(s,i,r={})=>{if(t(this._listeners,s)||e(this._listeners,s,[]),this.emit("newListener",s,i),!t(this._wildcardsRegex,s)){const t=s.split(this.delimiter).map((e=>"*"===e?"\\w*":e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"))),i=new RegExp(`^${t.join("\\"+this.delimiter)}$`);e(this._wildcardsRegex,s,i)}t(this._listenerRegex,s)||e(this._listenerRegex,s,new RegExp(s)),this._listeners[s].push({callback:i,once:!!r?.once})},this.on=this.addListener,this.once=(e,t,s={})=>this.addListener(e,t,{...s,once:!0}),this._removeListener=(e,t)=>{if(this.listenerCount(e)){let s=this._listeners[e].findIndex((e=>e?.callback===t));if(s>-1)return this._listeners[e].splice(s,1),!0}return!1},this.removeListener=(e,t)=>(this._removeListener(e,t)&&this.emit("removeListener",e,t),this),this.off=this.removeListener,this.removeAllListeners=e=>{if(e&&this.listeners(e).length){const t=this.listeners(e);delete this._listeners[e];for(const s of t)this.emit("removeListener",e,s)}return this},this.eventNames=()=>Object.keys(this._listeners),this.listenerCount=e=>e&&t(this._listeners,e)?this._listeners[e].length:0,this.listeners=e=>e&&t(this._listeners,e)?this._listeners[e].map((e=>e.callback)):[],this._getStack=()=>{const e=Error.prepareStackTrace,t=new Error;Error.prepareStackTrace=(e,t)=>t;const s=t.stack;return Error.prepareStackTrace=e,s?.slice(2)||[]},this._callListeners=(e,s,i)=>{if(e&&t(this._listeners,e))for(const t of this._listeners[e])t.once&&this._removeListener(e,t?.callback),t?.callback?.(s,...i)},this._callAsyncListeners=(e,s,i)=>{const r=[];if(e&&t(this._listeners,e))for(const t of this._listeners[e])t.once&&this._removeListener(e,t?.callback),r.push(t?.callback?.(s,...i));return r},this.emit=(e,...s)=>{const i={event:e};this.includeStack&&(i.stack=this._getStack().map((e=>({typeName:e.getTypeName(),methodName:e.getMethodName(),function:e.getFunction(),functionName:e.getFunctionName(),fileName:e.getFileName(),lineNumber:e.getLineNumber()}))));let r=!1;if("wildcard"===this.mode)for(const t in this._listeners)this._wildcardsRegex[t]?.test?.(e)&&(this._callListeners(t,i,s),r=!0);else if("regex"===this.mode)for(const t in this._listeners)this._listenerRegex[t]?.test?.(e)&&(this._callListeners(t,i,s),r=!0);else t(this._listeners,e)&&(this._callListeners(e,i,s),r=!0);return r},this.emitAsync=async(e,...s)=>{const i={event:e};this.includeStack&&(i.stack=this._getStack().map((e=>({typeName:e.getTypeName(),methodName:e.getMethodName(),function:e.getFunction(),functionName:e.getFunctionName(),fileName:e.getFileName(),lineNumber:e.getLineNumber()}))));let r=[];if("wildcard"===this.mode)for(const t in this._listeners)this._wildcardsRegex[t]?.test?.(e)&&r.push(...this._callAsyncListeners(t,i,s));else if("regex"===this.mode)for(const t in this._listeners)this._listenerRegex[t]?.test?.(e)&&r.push(...this._callAsyncListeners(t,i,s));else t(this._listeners,e)&&(r=this._callAsyncListeners(e,i,s));return!!r?.length&&(await Promise.allSettled(r),!0)},s&&(this.mode=s),void 0!==i&&(this.includeStack=i),r&&(this.delimiter=r)}}}();
